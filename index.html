<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://geespot.github.io">
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="华中农业大学，就职于欧冶电商，擅长linux系统运维，为提高工作效率写点小工具辅助，此为博客一枚。">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://geespot.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="华中农业大学，就职于欧冶电商，擅长linux系统运维，为提高工作效率写点小工具辅助，此为博客一枚。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="华中农业大学，就职于欧冶电商，擅长linux系统运维，为提高工作效率写点小工具辅助，此为博客一枚。">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/images/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">记事薄</a></h1>
		</hgroup>

		
		<p class="header-subtitle">geespot的博客</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/技术/">技术</a></li>
	        
				<li><a href="/tags/介绍/">介绍</a></li>
	        
				<li><a href="/tags/随笔/">随笔</a></li>
	        
				<li><a href="/tags/数据库/">数据库</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/geespot/geespot.github.io" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
		        
					<a class="mail" target="_blank" href="mailto:geespot@163.com" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-sort"></i></div>
  		<h1 class="header-author js-mobile-header hide">记事薄</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/images/avatar.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">记事薄</h1>
			</hgroup>
			
			<p class="header-subtitle">geespot的博客</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/技术/">技术</a></li>
		        
					<li><a href="/tags/介绍/">介绍</a></li>
		        
					<li><a href="/tags/随笔/">随笔</a></li>
		        
					<li><a href="/tags/数据库/">数据库</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/geespot/geespot.github.io" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			        
						<a class="mail" target="_blank" href="mailto:geespot@163.com" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-kafka-info" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/kafka-info/">kafka_info</a>
    </h1>
  

        <a href="/2017/01/05/kafka-info/" class="archive-article-date">
  	<time datetime="2017-01-05T01:33:26.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-01-05</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h3><p>1.简介<br> Kafka is a distributed,partitioned,replicated commit logservice。它提供了类似于JMS的特性，但是在设计实现上完全不同，此外它并不是JMS 规范的实现。kafka对消息保存时根据Topic进行归类，发送消息者成为Producer,消息接受者成为Consumer,此外kafka集群有多个kafka实例组成，每个实例(server)成为broker。无论是kafka集群，还是producer和consumer都依赖于zookeeper来保证系统可用性集群保存一些meta信息。</p>
<p>2.Topics/logs<br>     一个Topic可以认为是一类消息，每个topic将被分成多个partition(区),每个partition在存储层面是append log文件。任何发布到此partition的消息都会被直接追加到log文件的尾部，每条消息在文件中的位置称为offset（偏移量），offset为一个long型数字，它是唯一标记一条消息。它唯一的标记一条消息。kafka并没有提供其他额外的索引机制来存储offset，因为在kafka中几乎不允许对消息进行“随机读写”。</p>
<p>kafka和JMS（Java Message Service）实现(activeMQ)不同的是:即使消息被消费,消息仍然不会被立即删除.日志文件将会根据broker中的配置要求,保留一定的时间之后删除;比如log文件保留2天,那么两天后,文件会被清除,无论其中的消息是否被消费.kafka通过这种简单的手段,来释放磁盘空间,以及减少消息消费之后对文件内容改动的磁盘IO开支.</p>
<p>对于consumer而言,它需要保存消费消息的offset,对于offset的保存和使用,有consumer来控制;当consumer正常消费消息时,offset将会”线性”的向前驱动,即消息将依次顺序被消费.事实上consumer可以使用任意顺序消费消息,它只需要将offset重置为任意值..(offset将会保存在zookeeper中,参见下文)</p>
<p>kafka集群几乎不需要维护任何consumer和producer状态信息,这些信息有zookeeper保存;因此producer和consumer的客户端实现非常轻量级,它们可以随意离开,而不会对集群造成额外的影响.</p>
<p>partitions的设计目的有多个.最根本原因是kafka基于文件存储.通过分区,可以将日志内容分散到多个server上,来避免文件尺寸达到单机磁盘的上限,每个partiton都会被当前server(kafka实例)保存;可以将一个topic切分多任意多个partitions,来消息保存/消费的效率.此外越多的partitions意味着可以容纳更多的consumer,有效提升并发消费的能力.(具体原理参见下文).</p>
<p>3、Distribution<br>    一个Topic的多个partitions,被分布在kafka集群中的多个server上;每个server(kafka实例)负责partitions中消息的读写操作;此外kafka还可以配置partitions需要备份的个数(replicas),每个partition将会被备份到多台机器上,以提高可用性.<br>    基于replicated方案,那么就意味着需要对多个备份进行调度;每个partition都有一个server为”leader”;leader负责所有的读写操作,如果leader失效,那么将会有其他follower来接管(成为新的leader);follower只是单调的和leader跟进,同步消息即可..由此可见作为leader的server承载了全部的请求压力,因此从集群的整体考虑,有多少个partitions就意味着有多少个”leader”,kafka会将”leader”均衡的分散在每个实例上,来确保整体的性能稳定.<br>    Producers<br>    Producer将消息发布到指定的Topic中,同时Producer也能决定将此消息归属于哪个partition;比如基于”round-robin”方式或者通过其他的一些算法等.<br>    Consumers<br>    本质上kafka只支持Topic.每个consumer属于一个consumer group;反过来说,每个group中可以有多个consumer.发送到Topic的消息,只会被订阅此Topic的每个group中的一个consumer消费.</p>
<p>如果所有的consumer都具有相同的group,这种情况和queue模式很像;消息将会在consumers之间负载均衡.<br>    如果所有的consumer都具有不同的group,那这就是”发布-订阅”;消息将会广播给所有的消费者.<br>    在kafka中,一个partition中的消息只会被group中的一个consumer消费;每个group中consumer消息消费互相独立;我们可以认为一个group是一个”订阅”者,一个Topic中的每个partions,只会被一个”订阅者”中的一个consumer消费,不过一个consumer可以消费多个partitions中的消息.kafka只能保证一个partition中的消息被某个consumer消费时,消息是顺序的.事实上,从Topic角度来说,消息仍不是有序的.<br>    kafka的设计原理决定,对于一个topic,同一个group中不能有多于partitions个数的consumer同时消费,否则将意味着某些consumer将无法得到消息.<br>    Guarantees<br>    1) 发送到partitions中的消息将会按照它接收的顺序追加到日志中<br>    2) 对于消费者而言,它们消费消息的顺序和日志中消息顺序一致.<br>    3) 如果Topic的”replicationfactor”为N,那么允许N-1个kafka实例失效.</p>
<h3 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h3><p>1、Messaging<br>    对于一些常规的消息系统,kafka是个不错的选择;partitons/replication和容错,可以使kafka具有良好的扩展性和性能优势.不过到目前为止,我们应该很清楚认识到,kafka并没有提供JMS中的”事务性””消息传输担保(消息确认机制)””消息分组”等企业级特性;kafka只能使用作为”常规”的消息系统,在一定程度上,尚未确保消息的发送与接收绝对可靠(比如,消息重发,消息发送丢失等)</p>
<p>2、Websit activity tracking<br>    kafka可以作为”网站活性跟踪”的最佳工具;可以将网页/用户操作等信息发送到kafka中.并实时监控,或者离线统计分析等</p>
<p>3、Log Aggregation<br>    kafka的特性决定它非常适合作为”日志收集中心”;application可以将操作日志”批量””异步”的发送到kafka集群中,而不是保存在本地或者DB中;kafka可以批量提交消息/压缩消息等,这对producer端而言,几乎感觉不到性能的开支.此时consumer端可以使hadoop等其他系统化的存储和分析系统.</p>
<h3 id="三、设计原理"><a href="#三、设计原理" class="headerlink" title="三、设计原理"></a>三、设计原理</h3><pre><code>kafka的设计初衷是希望作为一个统一的信息收集平台,能够实时的收集反馈信息,并需要能够支撑较大的数据量,且具备良好的容错能力.

1、持久性
kafka使用文件存储消息,这就直接决定kafka在性能上严重依赖文件系统的本身特性.且无论任何OS下,对文件系统本身的优化几乎没有可能.文件缓存/直接内存映射等是常用的手段.因为kafka是对日志文件进行append操作,因此磁盘检索的开支是较小的;同时为了减少磁盘写入的次数,broker会将消息暂时buffer起来,当消息的个数(或尺寸)达到一定阀值时,再flush到磁盘,这样减少了磁盘IO调用的次数.
</code></pre><p>2、性能<br>    需要考虑的影响性能点很多,除磁盘IO之外,我们还需要考虑网络IO,这直接关系到kafka的吞吐量问题.kafka并没有提供太多高超的技巧;对于producer端,可以将消息buffer起来,当消息的条数达到一定阀值时,批量发送给broker;对于consumer端也是一样,批量fetch多条消息.不过消息量的大小可以通过配置文件来指定.对于kafka broker端,似乎有个sendfile系统调用可以潜在的提升网络IO的性能:将文件的数据映射到系统内存中,socket直接读取相应的内存区域即可,而无需进程再次copy和交换. 其实对于producer/consumer/broker三者而言,CPU的开支应该都不大,因此启用消息压缩机制是一个良好的策略;压缩需要消耗少量的CPU资源,不过对于kafka而言,网络IO更应该需要考虑.可以将任何在网络上传输的消息都经过压缩.kafka支持gzip/snappy等多种压缩方式.</p>
<pre><code>3、生产者
负载均衡: producer将会和Topic下所有partition leader保持socket连接;消息由producer直接通过socket发送到broker,中间不会经过任何&quot;路由层&quot;.事实上,消息被路由到哪个partition上,有producer客户端决定.比如可以采用&quot;random&quot;&quot;key-hash&quot;&quot;轮询&quot;等,如果一个topic中有多个partitions,那么在producer端实现&quot;消息均衡分发&quot;是必要的.

其中partition leader的位置(host:port)注册在zookeeper中,producer作为zookeeper client,已经注册了watch用来监听partition leader的变更事件.
异步发送：将多条消息暂且在客户端buffer起来，并将他们批量的发送到broker，小数据IO太多，会拖慢整体的网络延迟，批量延迟发送事实上提升了网络效率。不过这也有一定的隐患，比如说当producer失效时，那些尚未发送的消息将会丢失。

4、消费者
consumer端向broker发送&quot;fetch&quot;请求,并告知其获取消息的offset;此后consumer将会获得一定条数的消息;consumer端也可以重置offset来重新消费消息.

在JMS实现中,Topic模型基于push方式,即broker将消息推送给consumer端.不过在kafka中,采用了pull方式,即consumer在和broker建立连接之后,主动去pull(或者说fetch)消息;这中模式有些优点,首先consumer端可以根据自己的消费能力适时的去fetch消息并处理,且可以控制消息消费的进度(offset);此外,消费者可以良好的控制消息消费的数量,batch fetch.

其他JMS实现,消息消费的位置是有prodiver保留,以便避免重复发送消息或者将没有消费成功的消息重发等,同时还要控制消息的状态.这就要求JMS broker需要太多额外的工作.在kafka中,partition中的消息只有一个consumer在消费,且不存在消息状态的控制,也没有复杂的消息确认机制,可见kafka broker端是相当轻量级的.当消息被consumer接收之后,consumer可以在本地保存最后消息的offset,并间歇性的向zookeeper注册offset.由此可见,consumer客户端也很轻量级.
</code></pre><p>5、消息传送机制<br>    对于JMS实现,消息传输担保非常直接:有且只有一次(exactly once).在kafka中稍有不同:<br>    1) at most once: 最多一次,这个和JMS中”非持久化”消息类似.发送一次,无论成败,将不会重发.<br>    2) at least once: 消息至少发送一次,如果消息未能接受成功,可能会重发,直到接收成功.<br>    3) exactly once: 消息只会发送一次.<br>    at most once: 消费者fetch消息,然后保存offset,然后处理消息;当client保存offset之后,但是在消息处理过程中出现了异常,导致部分消息未能继续处理.那么此后”未处理”的消息将不能被fetch到,这就是”at most once”.<br>    at least once: 消费者fetch消息,然后处理消息,然后保存offset.如果消息处理成功之后,但是在保存offset阶段zookeeper异常导致保存操作未能执行成功,这就导致接下来再次fetch时可能获得上次已经处理过的消息,这就是”at least once”，原因offset没有及时的提交给zookeeper，zookeeper恢复正常还是之前offset状态.<br>    exactly once: kafka中并没有严格的去实现(基于2阶段提交,事务),我们认为这种策略在kafka中是没有必要的.<br>    通常情况下”at-least-once”是我们搜选.(相比at most once而言,重复接收数据总比丢失数据要好).</p>
<pre><code>6、复制备份
kafka将每个partition数据复制到多个server上,任何一个partition有一个leader和多个follower(可以没有);备份的个数可以通过broker配置文件来设定.leader处理所有的read-write请求,follower需要和leader保持同步.Follower和consumer一样,消费消息并保存在本地日志中;leader负责跟踪所有的follower状态,如果follower&quot;落后&quot;太多或者失效,leader将会把它从replicas同步列表中删除.当所有的follower都将一条消息保存成功,此消息才被认为是&quot;committed&quot;,那么此时consumer才能消费它.即使只有一个replicas实例存活,仍然可以保证消息的正常发送和接收,只要zookeeper集群存活即可.(不同于其他分布式存储,比如hbase需要&quot;多数派&quot;存活才行)
当leader失效时,需在followers中选取出新的leader,可能此时follower落后于leader,因此需要选择一个&quot;up-to-date&quot;的follower.选择follower时需要兼顾一个问题,就是新leaderserver上所已经承载的partition leader的个数,如果一个server上有过多的partition leader,意味着此server将承受着更多的IO压力.在选举新leader,需要考虑到&quot;负载均衡&quot;.

7.日志
如果一个topic的名称为&quot;my_topic&quot;,它有2个partitions,那么日志将会保存在my_topic_0和my_topic_1两个目录中;日志文件中保存了一序列&quot;log entries&quot;(日志条目),每个log entry格式为&quot;4个字节的数字N表示消息的长度&quot; + &quot;N个字节的消息内容&quot;;每个日志都有一个offset来唯一的标记一条消息,offset的值为8个字节的数字,表示此消息在此partition中所处的起始位置..每个partition在物理存储层面,有多个log file组成(称为segment).segmentfile的命名为&quot;最小offset&quot;.kafka.例如&quot;00000000000.kafka&quot;;其中&quot;最小offset&quot;表示此segment中起始消息的offset.

其中每个partiton中所持有的segments列表信息会存储在zookeeper中.
当segment文件尺寸达到一定阀值时(可以通过配置文件设定,默认1G),将会创建一个新的文件;当buffer中消息的条数达到阀值时将会触发日志信息flush到日志文件中,同时如果&quot;距离最近一次flush的时间差&quot;达到阀值时,也会触发flush到日志文件.如果broker失效,极有可能会丢失那些尚未flush到文件的消息.因为server意外实现,仍然会导致log文件格式的破坏(文件尾部),那么就要求当server启东是需要检测最后一个segment的文件结构是否合法并进行必要的修复.
获取消息时,需要指定offset和最大chunk尺寸,offset用来表示消息的起始位置,chunk size用来表示最大获取消息的总长度(间接的表示消息的条数).根据offset,可以找到此消息所在segment文件,然后根据segment的最小offset取差值,得到它在file中的相对位置,直接读取输出即可.
日志文件的删除策略非常简单:启动一个后台线程定期扫描log file列表,把保存时间超过阀值的文件直接删除(根据文件的创建时间).为了避免删除文件时仍然有read操作(consumer消费),采取copy-on-write方式.

8、分配
kafka使用zookeeper来存储一些meta信息,并使用了zookeeper watch机制来发现meta信息的变更并作出相应的动作(比如consumer失效,触发负载均衡等)
1) Broker node registry: 当一个kafkabroker启动后,首先会向zookeeper注册自己的节点信息(临时znode),同时当broker和zookeeper断开连接时,此znode也会被删除.
格式: /broker/ids/[0...N]   --&gt;host:port;其中[0..N]表示broker id,每个broker的配置文件中都需要指定一个数字类型的id(全局不可重复),znode的值为此broker的host:port信息.
2) Broker Topic Registry: 当一个broker启动时,会向zookeeper注册自己持有的topic和partitions信息,仍然是一个临时znode.
格式: /broker/topics/[topic]/[0...N]  其中[0..N]表示partition索引号.
3) Consumer and Consumer group: 每个consumer客户端被创建时,会向zookeeper注册自己的信息;此作用主要是为了&quot;负载均衡&quot;.
一个group中的多个consumer可以交错的消费一个topic的所有partitions;简而言之,保证此topic的所有partitions都能被此group所消费,且消费时为了性能考虑,让partition相对均衡的分散到每个consumer上.
4) Consumer id Registry: 每个consumer都有一个唯一的ID(host:uuid,可以通过配置文件指定,也可以由系统生成),此id用来标记消费者信息.
格式:/consumers/[group_id]/ids/[consumer_id]
仍然是一个临时的znode,此节点的值为{&quot;topic_name&quot;:#streams...},即表示此consumer目前所消费的topic + partitions列表.
5) Consumer offset Tracking: 用来跟踪每个consumer目前所消费的partition中最大的offset.
格式:/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]--&gt;offset_value
此znode为持久节点,可以看出offset跟group_id有关,以表明当group中一个消费者失效,其他consumer可以继续消费.
6) Partition Owner registry: 用来标记partition被哪个consumer消费.临时znode
格式:/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]--&gt;consumer_node_id当consumer启动时,所触发的操作:
A) 首先进行&quot;Consumer id Registry&quot;;
B) 然后在&quot;Consumer id Registry&quot;节点下注册一个watch用来监听当前group中其他consumer的&quot;leave&quot;和&quot;join&quot;;只要此znode path下节点列表变更,都会触发此group下consumer的负载均衡.(比如一个consumer失效,那么其他consumer接管partitions).
C) 在&quot;Broker id registry&quot;节点下,注册一个watch用来监听broker的存活情况;如果broker列表变更,将会触发所有的groups下的consumer重新balance.

1) Producer端使用zookeeper用来&quot;发现&quot;broker列表,以及和Topic下每个partition leader建立socket连接并发送消息.
2) Broker端使用zookeeper用来注册broker信息,已经监测partitionleader存活性.
3) Consumer端使用zookeeper用来注册consumer信息,其中包括consumer消费的partition列表等,同时也用来发现broker列表,并和partition leader建立socket连接,并获取消息.
</code></pre><p>四、主要配置</p>
<pre><code>1、Broker配置



2.Consumer主要配置
</code></pre><p>3.Producer主要配置</p>
<p>以上是关于kafka一些基础说明，在其中我们知道如果要kafka正常运行，必须配置zookeeper，否则无论是kafka集群还是客户端的生存者和消费者都无法正常的工作的，以下是对zookeeper进行一些简单的介绍：</p>
<p>五、zookeeper集群<br>    zookeeper是一个为分布式应用提供一致性服务的软件，它是开源的Hadoop项目的一个子项目，并根据google发表的一篇论文来实现的。zookeeper为分布式系统提供了高笑且易于使用的协同服务，它可以为分布式应用提供相当多的服务，诸如统一命名服务，配置管理，状态同步和组服务等。zookeeper接口简单，我们不必过多地纠结在分布式系统编程难于处理的同步和一致性问题上，你可以使用zookeeper提供的现成(off-the-shelf)服务来实现来实现分布式系统额配置管理，组管理，Leader选举等功能。<br>    zookeeper集群的安装,准备三台服务器server1:192.168.0.1,server2:192.168.0.2,<br>    server3:192.168.0.3.<br>    1)下载zookeeper<br>    到<a href="http://zookeeper.apache.org/releases.html去下载最新版本Zookeeper-3.4.5的安装包zookeeper-3.4.5.tar.gz.将文件保存server1的~目录下" target="_blank" rel="external">http://zookeeper.apache.org/releases.html去下载最新版本Zookeeper-3.4.5的安装包zookeeper-3.4.5.tar.gz.将文件保存server1的~目录下</a><br>    2)安装zookeeper<br>    先在服务器server分别执行a-c步骤<br>    a)解压<br>    tar -zxvf zookeeper-3.4.5.tar.gz<br>    解压完成后在目录~下会发现多出一个目录zookeeper-3.4.5,重新命令为zookeeper<br>    b）配置<br>    将conf/zoo_sample.cfg拷贝一份命名为zoo.cfg，也放在conf目录下。然后按照如下值修改其中的配置：</p>
<pre><code># The number of milliseconds of each tick
tickTime=2000
# The number of ticks that the initial
# synchronization phase can take
initLimit=10
# The number of ticks that can pass between
# sending a request and getting an acknowledgement
syncLimit=5
# the directory where the snapshot is stored.
# do not use /tmp for storage, /tmp here is just
# example sakes.
dataDir=/home/wwb/zookeeper /data
dataLogDir=/home/wwb/zookeeper/logs
# the port at which the clients will connect
clientPort=2181
#
# Be sure to read the maintenance section of the
# administrator guide before turning on autopurge.
#http://zookeeper.apache.org/doc/ ... html#sc_maintenance
#
# The number of snapshots to retain in dataDir
#autopurge.snapRetainCount=3
# Purge task interval in hours
# Set to &quot;0&quot; to disable auto purge feature
#autopurge.purgeInterval=1
server.1=192.168.0.1:3888:4888
server.2=192.168.0.2:3888:4888
server.3=192.168.0.3:3888:4888
tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。
dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。
clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。
initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒
syncLimit：这个配置项标识 Leader 与Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是2*2000=4 秒
server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号
</code></pre><p>注意:dataDir,dataLogDir中的wwb是当前登录用户名，data，logs目录开始是不存在，需要使用mkdir命令创建相应的目录。并且在该目录下创建文件myid,serve1,server2,server3该文件内容分别为1,2,3。<br>针对服务器server2,server3可以将server1复制到相应的目录，不过需要注意dataDir,dataLogDir目录,并且文件myid内容分别为2,3<br>    3)依次启动server1，server2,server3的zookeeper.<br>    /home/wwb/zookeeper/bin/zkServer.sh start,出现类似以下内容<br>    JMX enabled by default<br>    Using config: /home/wwb/zookeeper/bin/../conf/zoo.cfg<br>    Starting zookeeper … STARTED<br>   4) 测试zookeeper是否正常工作，在server1上执行以下命令<br>    /home/wwb/zookeeper/bin/zkCli.sh -server192.168.0.2:2181,出现类似以下内容<br>    JLine support is enabled<br>    2013-11-27 19:59:40,560 - INFO      [main-SendThread(localhost.localdomain:2181):ClientCnxn$SendThread@736]- Session   establishmentcomplete on server localhost.localdomain/127.0.0.1:2181, sessionid =    0x1429cdb49220000, negotiatedtimeout = 30000<br>    WATCHER::</p>
<pre><code>WatchedEvent state:SyncConnected type:None path:null
[zk: 127.0.0.1:2181(CONNECTED) 0] [root@localhostzookeeper2]#  
即代表集群构建成功了,如果出现错误那应该是第三部时没有启动好集群，
</code></pre><p>运行，先利用<br>    ps aux | grep zookeeper查看是否有相应的进程的，没有话，说明集群启动出现问题，可以在每个服务器上使用<br>    ./home/wwb/zookeeper/bin/zkServer.sh stop。再依次使用./home/wwb/zookeeper/binzkServer.sh start，这时在执行4一般是没有问题，如果还是有问题，那么先stop再到bin的上级目录执行./bin/zkServer.shstart试试。<br>注意：zookeeper集群时，zookeeper要求半数以上的机器可用，zookeeper才能提供服务。<br>六、kafka集群<br>(利用上面server1,server2,server3,下面以server1为实例)<br>    1)下载kafka0.8(<a href="http://kafka.apache.org/downloads.html),保存到服务器/home/wwb目录下kafka-0.8.0-beta1-src.tgz(kafka_2.8.0-0.8.0-beta1.tgz" target="_blank" rel="external">http://kafka.apache.org/downloads.html),保存到服务器/home/wwb目录下kafka-0.8.0-beta1-src.tgz(kafka_2.8.0-0.8.0-beta1.tgz</a>)<br>    2)解压 tar -zxvf kafka-0.8.0-beta1-src.tgz,产生文件夹kafka-0.8.0-beta1-src更改为kafka01<br>3)配置<br>    修改kafka01/config/server.properties,其中broker.id,log.dirs,zookeeper.connect必须根据实际情况进行修改，其他项根据需要自行斟酌。大致如下：<br>     broker.id=1<br>     port=9091<br>     num.network.threads=2<br>     num.io.threads=2<br>     socket.send.buffer.bytes=1048576<br>    socket.receive.buffer.bytes=1048576<br>     socket.request.max.bytes=104857600<br>    log.dir=./logs<br>    num.partitions=2<br>    log.flush.interval.messages=10000<br>    log.flush.interval.ms=1000<br>    log.retention.hours=168  </p>
<pre><code>#log.retention.bytes=1073741824  
log.segment.bytes=536870912  
num.replica.fetchers=2  
log.cleanup.interval.mins=10  
zookeeper.connect=192.168.0.1:2181,192.168.0.2:2182,192.168.0.3:2183  
zookeeper.connection.timeout.ms=1000000  
kafka.metrics.polling.interval.secs=5  
kafka.metrics.reporters=kafka.metrics.KafkaCSVMetricsReporter  
kafka.csv.metrics.dir=/tmp/kafka_metrics  
kafka.csv.metrics.reporter.enabled=false
</code></pre><p>4）初始化因为kafka用scala语言编写，因此运行kafka需要首先准备scala相关环境。</p>
<pre><code>&gt; cd kafka01  
&gt; ./sbt update  
&gt; ./sbt package  
&gt; ./sbt assembly-package-dependency
</code></pre><p>在第二个命令时可能需要一定时间，由于要下载更新一些依赖包。所以请大家 耐心点。<br>5) 启动kafka01</p>
<pre><code>&gt;JMX_PORT=9997 bin/kafka-server-start.sh config/server.properties &amp;  
</code></pre><p>a)kafka02操作步骤与kafka01雷同，不同的地方如下<br>    修改kafka02/config/server.properties<br>    broker.id=2<br>    port=9092</p>
<pre><code>##其他配置和kafka-0保持一致
启动kafka02
JMX_PORT=9998 bin/kafka-server-start.shconfig/server.properties &amp;  
</code></pre><p>b)kafka03操作步骤与kafka01雷同，不同的地方如下<br>    修改kafka03/config/server.properties<br>    broker.id=3<br>    port=9093</p>
<pre><code>##其他配置和kafka-0保持一致
启动kafka02
JMX_PORT=9999 bin/kafka-server-start.shconfig/server.properties &amp;
</code></pre><p>6)创建Topic(包含一个分区，三个副本)</p>
<pre><code>&gt;bin/kafka-create-topic.sh--zookeeper 192.168.0.1:2181 --replica 3 --partition 1 --topicmy-replicated-topic
</code></pre><p>7)查看topic情况</p>
<pre><code>&gt;bin/kafka-list-top.sh --zookeeper 192.168.0.1:2181
topic: my-replicated-topic  partition: 0 leader: 1  replicas: 1,2,0  isr: 1,2,0
</code></pre><p>8)创建发送者</p>
<blockquote>
<p>bin/kafka-console-producer.sh–broker-list 192.168.0.1:9091 –topic my-replicated-topic<br>    my test message1<br>    my test message2<br>    ^C<br>9)创建消费者<br>bin/kafka-console-consumer.sh –zookeeper127.0.0.1:2181 –from-beginning –topic my-replicated-topic<br>    …<br>    my test message1<br>    my test message2</p>
</blockquote>
<p>10)杀掉server1上的broker</p>
<blockquote>
<p>pkill -9 -f config/server.properties<br>11)查看topic<br>bin/kafka-list-top.sh –zookeeper192.168.0.1:2181<br>  topic: my-replicated-topic  partition: 0 leader: 1  replicas: 1,2,0  isr: 1,2,0<br>发现topic还正常的存在<br>11）创建消费者，看是否能查询到消息<br>bin/kafka-console-consumer.sh –zookeeper192.168.0.1:2181 –from-beginning –topic my-replicated-topic<br>    …<br>    my test message 1<br>    my test message 2<br>    ^C<br>说明一切都是正常的。<br>OK,以上就是对Kafka个人的理解，不对之处请大家及时指出。<br>补充说明：<br>1、public Map<string, list<kafkastream<byte[],="" byte[]="">&gt;&gt; createMessageStreams(Map<string, integer=""> topicCountMap)，其中该方法的参数Map的key为topic名称，value为topic对应的分区数，譬如说如果在kafka中不存在相应的topic时，则会创建一个topic，分区数为value，如果存在的话，该处的value则不起什么作用</string,></string,></p>
</blockquote>
<p>2、关于生产者向指定的分区发送数据，通过设置partitioner.class的属性来指定向那个分区发送数据，如果自己指定必须编写相应的程序，默认是kafka.producer.DefaultPartitioner,分区程序是基于散列的键。</p>
<p>3、在多个消费者读取同一个topic的数据，为了保证每个消费者读取数据的唯一性，必须将这些消费者group_id定义为同一个值，这样就构建了一个类似队列的数据结构，如果定义不同，则类似一种广播结构的。</p>
<p>4、在consumerapi中，参数设计到数字部分，类似Map<string,integer>,<br>numStream,指的都是在topic不存在的时，会创建一个topic，并且分区个数为Integer,numStream,注意如果数字大于broker的配置中num.partitions属性，会以num.partitions为依据创建分区个数的。</string,integer></p>
<p>5、producerapi，调用send时，如果不存在topic，也会创建topic，在该方法中没有提供分区个数的参数，在这里分区个数是由服务端broker的配置中num.partitions属性决定的<br>关于kafka说明可以参考：<a href="http://kafka.apache.org/documentation.html" target="_blank" rel="external">http://kafka.apache.org/documentation.html</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/介绍/">介绍</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-calendar"></i>
	<a class="article-category-link" href="/categories/linux/">linux</a><a class="article-category-link" href="/categories/linux/运维/">运维</a><a class="article-category-link" href="/categories/linux/运维/开发/">开发</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/01/05/kafka-info/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-luasql-oracle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/29/luasql-oracle/">luasql-oracle</a>
    </h1>
  

        <a href="/2016/12/29/luasql-oracle/" class="archive-article-date">
  	<time datetime="2016-12-29T02:39:20.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-29</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一安装-mac"><a href="#一安装-mac" class="headerlink" title="一安装  mac"></a>一安装  mac</h3><p>编译配置：</p>
<pre><code class="bash">git <span class="built_in">clone</span> https://github.com/keplerproject/luasql
<span class="built_in">cd</span>  luasql
vim config
<span class="comment"># Lua version and dirs</span>
LUA_LIBDIR ?= $(PREFIX)/lib/lua/$(LUA_SYS_VER)
LUA_DIR ?= $(PREFIX)/share/lua/$(LUA_SYS_VER)
LUA_INC ?= /usr/<span class="built_in">local</span>/include/luajit-2.1

<span class="comment"># - Oracle OCI8</span>
DRIVER_LIBS_oci8 ?= -L/opt/oracle/instantclient_11_2 -lz -lclntsh
DRIVER_INCS_oci8 ?= -I/opt/oracle/instantclient_11_2/sdk/include
</code></pre>
<p>安装 instantclient-sqlplus<br>下载sql:<br><a href="http://download.oracle.com/otn/mac/instantclient/11204/instantclient-sqlplus-macos.x64-11.2.0.4.0.zip?AuthParam=1483339513_c6c20f6dbd36fa8991b05173024a45a6" target="_blank" rel="external">instantclient-sqlplus</a></p>
<pre><code class="bash"><span class="built_in">cd</span> /opt/oracle/instantclient_11_2
unzip instantclient-sqlplus-macos.x64-11.2.0.4.0.zip
mv instantclient-sqlplus-macos/* .
mkdir  /opt/oracle/instantclient_11_2/network/admin/ 
<span class="built_in">cd</span> /opt/oracle/instantclient_11_2/network/admin/ 
<span class="comment"># 增加  tnsnames.ora </span>
cat  /opt/oracle/instantclient_11_2/network/admin/tnsnames.ora 
UATNEW_RNDEFAULT =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 10.57.115.157)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = newuat)
    )
  )
</code></pre>
<p>luajit 测试：</p>
<pre><code class="bash">cat conndb.lua 
<span class="built_in">local</span> driver = require <span class="string">"luasql.oci8"</span>
<span class="built_in">print</span>(driver)

<span class="built_in">local</span> env = driver.oci8()
<span class="built_in">print</span>(env)

<span class="built_in">print</span> (os.time())
<span class="built_in">local</span> dbcon = assert (env:connect(<span class="string">"UATNEW_RNDEFAULT"</span>, <span class="string">"rntrade"</span>, <span class="string">"QWER1234"</span>))
<span class="built_in">print</span>( dbcon )

-- <span class="built_in">local</span> sql = <span class="string">"select count(1) as c from account_address"</span>
-- <span class="built_in">local</span> sql = <span class="string">"select * from send_messges_info WHERE ROWNUM &lt;= 10"</span>
<span class="built_in">local</span> sql = <span class="string">"select count(*) from send_messges_info "</span>
<span class="built_in">local</span> cursor = dbcon:execute(sql)
<span class="built_in">print</span>(cursor)



<span class="built_in">local</span> ret = cursor:fetch({},<span class="string">"a"</span>)
<span class="keyword">for</span> k , v <span class="keyword">in</span> pairs(ret) <span class="keyword">do</span>
   <span class="built_in">print</span>(string.format(<span class="string">"%s %s"</span>,k , v ))
   ngx.say(string.format(<span class="string">"短信总数%s %s"</span>,k , v ))
end
</code></pre>
<h3 id="安装-lua-cjson"><a href="#安装-lua-cjson" class="headerlink" title="安装 lua-cjson"></a>安装 lua-cjson</h3><pre><code class="bash">git <span class="built_in">clone</span> https://github.com/mpx/lua-cjson.git
<span class="built_in">cd</span> lua-cjson
<span class="comment"># 修改 lua 目录：</span>
LUA_INC ?= /usr/<span class="built_in">local</span>/include/luajit-2.1
<span class="comment">## MacOSX (Macports)</span>
<span class="comment">#PREFIX =            /opt/local</span>
<span class="comment">#  修改CJSON_LDFLAGS =     -shared</span>
CJSON_LDFLAGS =     -bundle -undefined dynamic_lookup
make
</code></pre>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-calendar"></i>
	<a class="article-category-link" href="/categories/linux/">linux</a><a class="article-category-link" href="/categories/linux/数据库/">数据库</a><a class="article-category-link" href="/categories/linux/数据库/运维/">运维</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/29/luasql-oracle/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-mysql-turning" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/27/mysql-turning/">mysql_turning</a>
    </h1>
  

        <a href="/2016/12/27/mysql-turning/" class="archive-article-date">
  	<time datetime="2016-12-27T05:52:37.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-27</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="服务器物理硬件优化"><a href="#服务器物理硬件优化" class="headerlink" title="服务器物理硬件优化"></a>服务器物理硬件优化</h3><p>1 磁盘寻道能力（磁盘I/O）<br>采用6块 磁盘 raid 1+0   千万不要做raid5, r<br>通常认为磁盘I/O 是制约mysql性能最大因素之一。<br>或者使用固态硬盘raid来提高I/O 。<br>对于日均访问量在100万pv以上的论坛，如果I/O 不好会造成mysql性能非常低下</p>
<p>2 CPU<br>3 内存 一般建议服务器内存不小于4G  (DELL R710)  现在内存 一般32G以上了</p>
<h3 id="mysql配置文件优化："><a href="#mysql配置文件优化：" class="headerlink" title="mysql配置文件优化："></a>mysql配置文件优化：</h3><p>skip-locking # 避免MySQL的外部锁定，减少出错几率增强稳定性。 skip-name-resolve</p>
<p>back_log = 500<br>　back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。只有如果期望在一个短时间内有很多连接，你需要增 加它，换句话说，这值对到来的TCP/IP连接的侦听队列的大小。你的操作系统在这个队列大小上有它自己的限制。试图设定 back_log高于你的操作系统的限制将是无效的。当你观察你的主机进程列表，发现大量 264084 | unauthenticated user | xxx.xxx.xxx.xxx | NULL | Connect | NULL | login | NULL 的待连接进程时，就要加大 back_log 的值了。默认数值是50，我把它改为500</p>
<p>key_buffer_size = 384M<br>key_buffer_size指定用于索引的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，系 统将开始换页并且真的变慢了。对于内存在4GB左右的服务器该参数可设置为384M或512M。通过检查状态 值Key_read_requests和Key_reads,可以知道key_buffer_size设置是否合理。比例key_reads / key_read_requests应该尽可能的低，至少是1:100，1:1000更好(上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得)。注意：该参数值设置的过大反而会是服务器整体效率降低!</p>
<p>max_allowed_packet = 32M<br>增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或mysqld必须返回大的结果行时mysqld才会分配更多 内存。该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出</p>
<p>table_cache = 512<br>table_cache指定表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问 表内容。通过检查峰值时间的状态值Open_tables和Opened_tables，可以决定是否需要增加table_cache的值。如果你发现 open_tables等于table_cache，并且opened_tables在不断增长，那么你就需要增加table_cache的值了(上述状 态值可以使用SHOW STATUS LIKE ‘Open%tables’获得)。注意，不能盲目地把table_cache设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。<br>sort_buffer_size = 4M</p>
<p>　　查询排序时所能使用的缓冲区大小。注意：该参数对应的分配内存是每连接独占!如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 4 = 400MB。所以，对于内存在4GB左右的服务器推荐设置为4-8M。</p>
<p>　　read_buffer_size = 4M</p>
<p>　　读查询操作所能使用的缓冲区大小。和sort_buffer_size一样，该参数对应的分配内存也是每连接独享!<br>　　join_buffer_size = 8M</p>
<p>　　联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享!<br>　　myisam_sort_buffer_size = 64M</p>
<p>　　MyISAM表发生变化时重新排序所需的缓冲<br>　　query_cache_size = 64M</p>
<p>　　指定MySQL查询缓冲区的大小。可以通过在MySQL控制台执行以下命令观察：</p>
<p>　　# &gt; SHOW VARIABLES LIKE ‘%query_cache%’; # &gt; SHOW STATUS LIKE ‘Qcache%’; # 如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况;</p>
<p>　　如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓 冲;Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。<br>　　thread_cache_size = 64<br>　　可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性 能可以这个变量值。通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用</p>
<p>　　tmp_table_size = 256M<br>　　max_connections = 1000</p>
<p>　　指定MySQL允许的最大连接进程数。如果在访问论坛时经常出现Too Many Connections的错误提示，则需要增大该参数值。</p>
<p>　　max_connect_errors = 10000000</p>
<p>　　对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST;。</p>
<p>　　wait_timeout = 10</p>
<p>　　指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。</p>
<p>　　thread_concurrency = 8</p>
<p>　　该参数取值为服务器逻辑CPU数量×2，在本例中，服务器有2颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为4 × 2 = 8</p>
<p>　　skip-networking</p>
<p>　　开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项!否则将无法正常连接!</p>
<p>　　long_query_time = 10</p>
<p>　　log-slow-queries =</p>
<p>　　log-queries-not-using-indexes</p>
<p>　　开启慢查询日志( slow query log )</p>
<p>　　慢查询日志对于跟踪有问题的查询非常有用。它记录所有查过long_query_time的查询，如果需要，还可以记录不使用索引的记录。下面是一个 慢查询日志的例子：</p>
<p>　　开启慢查询日志，需要设置参数log_slow_queries、long_query_times、log-queries-not-using- indexes。</p>
<p>　　log_slow_queries指定日志文件，如果不提供文件名，MySQL将自己产生缺省文件名。long_query_times指定慢查询的 阈值，缺省是10秒。log-queries-not-using-indexes是4.1.0以后引入的参数，它指示记录不使用索引的查询。设置 long_query_time=10</p>
<p>　另外附上使用show status命令查看mysql状态相关的值及其含义：</p>
<p>　　使用show status命令</p>
<p>　　含义如下:</p>
<p>　　aborted_clients 客户端非法中断连接次数<br>　　aborted_connects 连接mysql失败次数<br>　　com_xxx xxx命令执行次数,有很多条<br>　　connections 连接mysql的数量<br>　　Created_tmp_disk_tables 在磁盘上创建的临时表<br>　　Created_tmp_tables 在内存里创建的临时表<br>　　Created_tmp_files 临时文件数<br>　　Key_read_requests The number of requests to read a key block from the cache<br>　　Key_reads The number of physical reads of a key block from disk<br>　　Max_used_connections 同时使用的连接数<br>　　Open_tables 开放的表<br>　　Open_files 开放的文件<br>　　Opened_tables 打开的表<br>　　Questions 提交到server的查询数<br>　　Sort_merge_passes 如果这个值很大,应该增加my.cnf中的sort_buffer值<br>　　Uptime 服务器已经工作的秒数</p>
<p>　　提升性能的建议:</p>
<p>　　1.如果opened_tables太大,应该把my.cnf中的table_cache变大<br>　　2.如果Key_reads太大,则应该把my.cnf中key_buffer_size变大.可以用 Key_reads/Key_read_requests计算出cache失败率<br>　　3.如果Handler_read_rnd太大,则你写的SQL语句里很多查询都是要扫描整个表,而没有发挥索引的键的作用<br>　　4.如果Threads_created太大,就要增加my.cnf中thread_cache_size的值.可以用 Threads_created/Connections计算cache命中率<br>　　5.如果Created_tmp_disk_tables太大,就要增加my.cnf中tmp_table_size的值,用基于内存的临时表代替基 于磁盘的</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-calendar"></i>
	<a class="article-category-link" href="/categories/linux/">linux</a><a class="article-category-link" href="/categories/linux/数据库/">数据库</a><a class="article-category-link" href="/categories/linux/数据库/运维/">运维</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/27/mysql-turning/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-mysql-performance" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/27/mysql-performance/">mysql_performance</a>
    </h1>
  

        <a href="/2016/12/27/mysql-performance/" class="archive-article-date">
  	<time datetime="2016-12-27T02:33:13.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-27</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Mysql数据库的优化技术"><a href="#Mysql数据库的优化技术" class="headerlink" title="Mysql数据库的优化技术:"></a>Mysql数据库的优化技术:</h3><p>对mysql优化是一个综合性的技术，主要包括:</p>
<p>表的设计合理化(符合3NF)<br>添加适当索引(index) [四种: 普通索引、主键索引、唯一索引unique、全文索引]<br>分表技术(水平分割、垂直分割)<br>读写[写: update/delete/add]分离<br>存储过程 [模块化编程，可以提高速度]<br>对mysql配置优化 [配置最大并发数my.ini, 调整缓存大小 ]<br>mysql服务器硬件升级<br>定时的去清除不需要的数据,定时进行碎片整理(MyISAM)</p>
<h3 id="数据库优化工作"><a href="#数据库优化工作" class="headerlink" title="数据库优化工作:"></a>数据库优化工作:</h3><p>一般来说，要保证数据库的效率，要做好以下四个方面的工作：</p>
<p>① 数据库设计<br>② sql语句优化<br>③ 数据库参数配置<br>④ 恰当的硬件资源和操作系统</p>
<p>此外，使用适当的存储过程，也能提升性能。</p>
<h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计:"></a>数据库表设计:</h3><p>通俗地理解三个范式，对于数据库设计大有好处。<br>在数据库设计中，为了更好地应用三个范式，就必须通俗地理解三个范式 通俗地理解是够用的理解，并不是最科学最准确的理解)：</p>
<p>第一范式：1NF是对属性的原子性约束，要求属性(列)具有原子性，不可再分解；(只要是关系型数据库都满足1NF)<br>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>第三范式：3NF是对字段冗余性的约束，它要求字段没有冗余。 没有冗余的数据库设计可以做到。</p>
<p>但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。</p>
<p>关系型数据库: mysql/oracle/db2/informix/sysbase/sql server<br>非关系型数据库: (特点: 面向对象或者集合)<br>NoSql数据库: MongoDB(特点是面向文档)<br>举例说明什么是适度冗余，或者说有理由的冗余!</p>
<p>单位信息           ……………………     学生活动记录<br>单位标识 <pi> I  M ……………………       活动标识<br>单位名称 VA32          ……………………       活动时间<br>Identifier_1 <pi> ………………………       积分<br>            …………………………………………       单位名称 冗余<br>            …………………………………………       Identifier_1 <pi></pi></pi></pi></p>
<p>面这个就是不合适的冗余，原因是:</p>
<p>在这里，为了提高学生活动记录的检索效率，把单位名称冗余到学生活动记录表里。单位信息有500条记录，而学生活动记录在一年内大概有200万数据量。 如果学生活动记录表不冗余这个单位名称字段，只包含三个int字段和一个timestamp字段，只占用了16字节，是一个很小的表。而冗余了一个 varchar(32)的字段后则是原来的3倍，检索起来相应也多了这么多的I/O。而且记录数相差悬殊，500 VS 2000000 ，导致更新一个单位名称还要更新4000条冗余记录。由此可见，这个冗余根本就是适得其反.</p>
<h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><p>通过show status命令了解各种SQL的执行频率。<br>定位执行效率较低的SQL语句-（重点select）<br>通过explain分析低效率的SQL<br>确定问题并采取相应的优化措施</p>
<pre><code class="sql"><span class="comment">-- select语句分类</span>
<span class="keyword">Select</span>
Dml 数据操作语言(<span class="keyword">insert</span> <span class="keyword">update</span> <span class="keyword">delete</span>)
dtl 数据事物语言(<span class="keyword">commit</span> <span class="keyword">rollback</span> <span class="keyword">savepoint</span>)
<span class="keyword">Ddl</span> 数据定义语言(<span class="keyword">create</span> <span class="keyword">alter</span> drop..)
Dcl(数据控制语言) <span class="keyword">grant</span> <span class="keyword">revoke</span>

<span class="comment">-- Show status 常用命令</span>
<span class="comment">--查询本次会话</span>
<span class="keyword">Show</span> <span class="keyword">session</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'com_%'</span>;     //<span class="keyword">show</span> <span class="keyword">session</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Com_select'</span>

<span class="comment">--查询全局</span>
<span class="keyword">Show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'com_%'</span>;

<span class="comment">-- 给某个用户授权</span>
<span class="keyword">grant</span> all <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'abc'</span>@<span class="string">'%'</span>;
<span class="comment">--为什么这样授权 'abc'表示用户名  '@' 表示host, 查看一下mysql-&gt;user表就知道了</span>

<span class="comment">--回收权限</span>
<span class="keyword">revoke</span> all <span class="keyword">on</span> *.* <span class="keyword">from</span> <span class="string">'abc'</span>@<span class="string">'%'</span>;

<span class="comment">--刷新权限[也可以不写]</span>
<span class="keyword">flush</span> <span class="keyword">privileges</span>;
</code></pre>
<h3 id="SQL语句优化-show参数"><a href="#SQL语句优化-show参数" class="headerlink" title="SQL语句优化-show参数"></a>SQL语句优化-show参数</h3><p>MySQL客户端连接成功后，通过使用show [session|global] status 命令可以提供服务器状态信息。其中的session来表示当前的连接的统计结果，global来表示自数据库上次启动至今的统计结果。默认是session级别的。<br>下面的例子：<br>show status like ‘Com_%’;<br>其中Com_XXX表示XXX语句所执行的次数。<br>重点注意：Com_select,Com_insert,Com_update,Com_delete通过这几个参数，可以容易地了解到当前数据库的应用是以插入更新为主还是以查询操作为主，以及各类的SQL大致的执行比例是多少。</p>
<p>还有几个常用的参数便于用户了解数据库的基本情况。<br>Connections：试图连接MySQL服务器的次数<br>Uptime：服务器工作的时间（单位秒）<br>Slow_queries：慢查询的次数 (默认是慢查询时间10s)</p>
<pre><code class="sql"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Connections'</span>
<span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Uptime'</span>
<span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Slow_queries'</span>
</code></pre>
<p>如何查询mysql的慢查询时间</p>
<pre><code class="sql"><span class="keyword">Show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;
</code></pre>
<p>修改mysql 慢查询时间</p>
<pre><code class="sql"><span class="keyword">set</span> long_query_time=<span class="number">2</span>;
</code></pre>
<h3 id="SQL语句优化-定位慢查询"><a href="#SQL语句优化-定位慢查询" class="headerlink" title="SQL语句优化-定位慢查询"></a>SQL语句优化-定位慢查询</h3><p>问题是： 如何从一个大项目中，迅速的定位执行速度慢的语句. (定位慢查询)<br>首先我们了解mysql数据库的一些运行状态如何查询(比如想知道当前mysql运行的时间/一共执行了多少次select/update/delete.. / 当前连接)<br>为了便于测试，我们构建一个大表(400 万)-&gt; 使用存储过程构建<br>默认情况下，mysql认为10秒才是一个慢查询.<br>修改mysql的慢查询.</p>
<pre><code class="sql"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span> ; //可以显示当前慢查询时间
<span class="keyword">set</span> long_query_time=<span class="number">1</span> ;//可以修改慢查询时间
</code></pre>
<p>构建大表-&gt;大表中记录有要求, 记录是不同才有用，否则测试效果和真实的相差大.创建:</p>
<pre><code class="sql"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept( <span class="comment">/*部门表*/</span>
deptno MEDIUMINT   <span class="keyword">UNSIGNED</span>  <span class="keyword">NOT</span> <span class="literal">NULL</span>  <span class="keyword">DEFAULT</span> <span class="number">0</span>,  <span class="comment">/*编号*/</span>
dname <span class="built_in">VARCHAR</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>  <span class="keyword">DEFAULT</span> <span class="string">""</span>, <span class="comment">/*名称*/</span>
loc <span class="built_in">VARCHAR</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">""</span> <span class="comment">/*地点*/</span>
) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ;


<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp
(empno  MEDIUMINT <span class="keyword">UNSIGNED</span>  <span class="keyword">NOT</span> <span class="literal">NULL</span>  <span class="keyword">DEFAULT</span> <span class="number">0</span>, <span class="comment">/*编号*/</span>
ename <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">""</span>, <span class="comment">/*名字*/</span>
job <span class="built_in">VARCHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">""</span>,<span class="comment">/*工作*/</span>
mgr MEDIUMINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,<span class="comment">/*上级编号*/</span>
hiredate <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,<span class="comment">/*入职时间*/</span>
sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,<span class="comment">/*薪水*/</span>
comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,<span class="comment">/*红利*/</span>
deptno MEDIUMINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="comment">/*部门编号*/</span>
)<span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ;


<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salgrade
(
grade MEDIUMINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,
losal <span class="built_in">DECIMAL</span>(<span class="number">17</span>,<span class="number">2</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,
hisal <span class="built_in">DECIMAL</span>(<span class="number">17</span>,<span class="number">2</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>
)<span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;
</code></pre>
<p>测试数据</p>
<pre><code class="sql">NSERT INTO salgrade VALUES (1,700,1200);
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">1201</span>,<span class="number">1400</span>);
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">1401</span>,<span class="number">2000</span>);
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">2001</span>,<span class="number">3000</span>);
<span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">3001</span>,<span class="number">9999</span>);
</code></pre>
<p>为了存储过程能够正常执行，我们需要把命令执行结束符修改delimiter<br>创建函数，该函数会返回一个指定长度的随机字符串</p>
<pre><code class="sql">create function rand_string(n INT) 
returns varchar(255) #该函数会返回一个字符串
begin 
#chars_str定义一个变量 chars_str,类型是 varchar(100),默认值'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
 declare chars_str varchar(100) default
   'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
 declare return_str varchar(255) default '';
 declare i int default 0;
 while i &lt; n do 
   set return_str =concat(return_str,substring(chars_str,floor(1+rand()*52),1));
   set i = i + 1;
   end while;
  return return_str;
  end
</code></pre>
<p>创建一个存储过程</p>
<pre><code class="sql"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_emp(<span class="keyword">in</span> <span class="keyword">start</span> <span class="built_in">int</span>(<span class="number">10</span>),<span class="keyword">in</span> max_num <span class="built_in">int</span>(<span class="number">10</span>))
<span class="keyword">begin</span>
<span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>; 
 <span class="keyword">set</span> autocommit = <span class="number">0</span>;  
 repeat
 <span class="keyword">set</span> i = i + <span class="number">1</span>;
 <span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span> ((<span class="keyword">start</span>+i) ,rand_string(<span class="number">6</span>),<span class="string">'SALESMAN'</span>,<span class="number">0001</span>,<span class="keyword">curdate</span>(),<span class="number">2000</span>,<span class="number">400</span>,<span class="keyword">rand</span>());
  until i = max_num
 <span class="keyword">end</span> <span class="keyword">repeat</span>;
   <span class="keyword">commit</span>;
 <span class="keyword">end</span>
</code></pre>
<p>#调用刚刚写好的函数, 1800000条记录,从100001号开始<br>call insert_emp(100001,4000000);<br>这时我们如果出现一条语句执行时间超过1秒中，就会统计到.<br>如果把慢查询的sql记录到我们的一个日志中<br>在默认情况下，低版本的mysql不会记录慢查询，需要在启动mysql时候，指定记录慢查询才可以<br>    bin\mysqld.exe - -safe-mode  - -slow-query-log [mysql5.5 可以在my.ini指定]<br>    bin\mysqld.exe –log-slow-queries=d:/abc.log [低版本mysql5.0可以在my.ini指定]<br>该慢查询日志会放在data目录下[在mysql5.0这个版本中时放在 mysql安装目录/data/下],在 mysql5.5.19下是需要查看<br>my.ini 的 datadir=”C:/Documents and Settings/All Users/Application Data/MySQL/MySQL Server 5.5/Data/“来确定.<br>在mysql5.6中，默认是启动记录慢查询的，my.ini的所在目录为：C:\ProgramData\MySQL\MySQL Server 5.6，其中有一个配置项<br>slow-query-log=1</p>
<p>针对 mysql5.5启动慢查询有两种方法<br>bin\mysqld.exe - -safe-mode  - -slow-query-log<br>也可以在my.ini 文件中配置:</p>
<pre><code class="bash">[mysqld]
<span class="comment"># The TCP/IP Port the MySQL Server will listen on</span>
port=3306
slow-query-log
</code></pre>
<p>通过慢查询日志定位执行效率较低的SQL语句。慢查询日志记录了所有执行时间超过long_query_time所设置的SQL语句。<br>show variables like ‘long_query_time’;<br>set long_query_time=2;</p>
<p>为dept表添加数据</p>
<pre><code class="sql">desc dept;
<span class="keyword">ALTER</span> <span class="keyword">table</span>  dept <span class="keyword">add</span> <span class="keyword">id</span> <span class="built_in">int</span> PRIMARY <span class="keyword">key</span> auto_increment;
<span class="keyword">CREATE</span> PRIMARY <span class="keyword">KEY</span> <span class="keyword">on</span> dept(<span class="keyword">id</span>);
<span class="keyword">create</span> <span class="keyword">INDEX</span> idx_dptno_dptname <span class="keyword">on</span> dept(deptno,dname);
<span class="keyword">INSERT</span> <span class="keyword">into</span> dept(deptno,dname,loc) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'研发部'</span>,<span class="string">'康和盛大厦5楼501'</span>);
<span class="keyword">INSERT</span> <span class="keyword">into</span> dept(deptno,dname,loc) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'产品部'</span>,<span class="string">'康和盛大厦5楼502'</span>);
<span class="keyword">INSERT</span> <span class="keyword">into</span> dept(deptno,dname,loc) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'财务部'</span>,<span class="string">'康和盛大厦5楼503'</span>);
<span class="keyword">UPDATE</span> emp <span class="keyword">set</span> deptno=<span class="number">1</span> <span class="keyword">where</span> empno=<span class="number">100002</span>;
</code></pre>
<p>[对emp表的记录可以为3600000 ,效果很明显慢]</p>
<p>select * from emp where empno=(select empno from emp where ename=’研发部’)</p>
<p>如果带上order by e.empno 速度就会更慢，有时会到1min多.</p>
<p>测试语句</p>
<pre><code class="sql"><span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.empno=<span class="number">100002</span>  <span class="keyword">and</span> e.deptno=d.deptno;
</code></pre>
<p>查看慢查询日志：默认为数据目录data中的host-name-slow.log。低版本的mysql需要通过在开启mysql时使用- -log-slow-queries[=file_name]来配置</p>
<h3 id="SQL语句优化-explain分析问题"><a href="#SQL语句优化-explain分析问题" class="headerlink" title="SQL语句优化-explain分析问题"></a>SQL语句优化-explain分析问题</h3><p>Explain select * from emp where ename=“wsrcla”<br>会产生如下信息：<br>select_type:表示查询的类型。<br>table:输出结果集的表<br>type:表示表的连接类型<br>possible_keys:表示查询时，可能使用的索引<br>key:表示实际使用的索引<br>key_len:索引字段的长度<br>rows:扫描出的行数(估算的行数)<br>Extra:执行情况的描述和说明</p>
<pre><code class="sql"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> ename=<span class="string">'JKLOIP'</span>
</code></pre>
<p>如果要测试Extra的filesort可以对上面的语句修改</p>
<pre><code class="sql"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> ename\G
</code></pre>
<p>XPLAIN详解<br>id<br>SELECT识别符。这是SELECT的查询序列号<br>id 示例</p>
<pre><code class="sql"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empno = <span class="number">1</span> <span class="keyword">and</span> ename = (<span class="keyword">SELECT</span> ename <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empno =  <span class="number">100001</span>) \G;
</code></pre>
<p>select_type<br>PRIMARY    :子查询中最外层查询<br>SUBQUERY : 子查询内层第一个SELECT，结果不依赖于外部查询<br>DEPENDENT SUBQUERY:子查询内层第一个SELECT，依赖于外部查询<br>UNION   :UNION语句中第二个SELECT开始后面所有SELECT，<br>SIMPLE<br>UNION RESULT UNION 中合并结果<br>Table<br>显示这一步所访问数据库中表名称<br>Type<br>对表访问方式<br>ALL：<br>SELECT <em> FROM emp \G<br>完整的表扫描 通常不好<br>SELECT </em> FROM (SELECT * FROM emp WHERE empno = 1) a ;<br>system：表仅有一行(=系统表)。这是const联接类型的一个特<br>const：表最多有一个匹配行<br>Possible_keys<br>该查询可以利用的索引，如果没有任何索引显示  null</p>
<p>Key<br>Mysql 从 Possible_keys 所选择使用索引<br>Rows<br>估算出结果集行数<br>Extra<br>查询细节信息<br>No tables ：Query语句中使用FROM DUAL 或不含任何FROM子句<br>Using filesort ：当Query中包含 ORDER BY 操作，而且无法利用索引完成排序，<br>Impossible WHERE noticed after reading const tables: MYSQL Query Optimizer<br>通过收集统计信息不可能存在结果<br>Using temporary：某些操作必须使用临时表，常见 GROUP BY  ; ORDER BY<br>Using where：不用读取表中所有信息，仅通过索引就可以获取所需数据;</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-calendar"></i>
	<a class="article-category-link" href="/categories/linux/">linux</a><a class="article-category-link" href="/categories/linux/数据库/">数据库</a><a class="article-category-link" href="/categories/linux/数据库/运维/">运维</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/27/mysql-performance/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-orange" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/22/orange/">orange</a>
    </h1>
  

        <a href="/2016/12/22/orange/" class="archive-article-date">
  	<time datetime="2016-12-22T07:11:59.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-22</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、介绍："><a href="#一、介绍：" class="headerlink" title="一、介绍："></a>一、介绍：</h3><p>Orange是基于插件设计的，基本思想是通过实现各种插件灵活的在Nginx的各个执行阶段进行逻辑处理。</p>
<p>Orange提供的默认插件功能如下：</p>
<p>全局的监控插件，可统计API访问情况、Nginx连接情况、流量统计、QPS等<br>自定义监控，可根据配置的规则筛选监控项，统计其各个指标<br>rewrite插件，可通过UI配置各种rewrite策略，省去手写nginx rewrite，然后重启的麻烦<br>redirect插件，实现请求重定向功能<br>HTTP Basic Authorization，为API动态配置鉴权<br>简单地WAF应用防火墙，可提取各个请求参数，通过各种匹配规则甄别需要禁止的流量<br>分流插件，可分为三个使用场景：<br>作为proxy，如代理后端的多个HTTP应用<br>用于AB测试<br>用于动态分流，API版本控制等<br>其它插件，用户可根据具体需要按规范编写即可。</p>
<p>使用场景</p>
<ul>
<li><p>Case 1 *<br>原来的Nginx配置文件中包含大量的rewrite语句，每次更改需要重启<br>有时候rewrite特别难写，比如我需要把来自于某个Host并且uri以/user开头的请求rewrite到以/some_host/user开头，如果是在Nginx里写，一般要通过if判断Host，再rewrite，可能需要多次调试和reload才能成功。这对于有经验的运维或是开发可能并不是难事，但对刚接手的新人或是不熟悉Nginx的运维人员来说，就是一件头疼事儿了<br>再想像一下，如果再加上几个限制条件，比如需要来自某些IP访问某个Host并且Header里含有某个标识变量的请求执行某个rewrite，Orz…<br>原来对于某个移动端API，客户端已经发布了很多个版本，每个版本的该API内部实现可能都不太一样，如果需要后端去兼容这个更改，可能就需要在代码中添加大量的if/else，或者给同一个职责的API取不同的名字(其它更好的实践暂且不表)。长此以往，API的版本管理可能就是一团乱麻</p>
</li>
<li><p>Case 2 *</p>
</li>
</ul>
<p>在内部系统中，大量模块或者异构的子系统之间都是通过HTTP交互的，这时不可避免的要引入一个七层负载，选型最多的基本上也就是Nginx了。对于内部网关的管理，可能存在的问题：</p>
<p>由于是内部使用，运维对外网隔离比较严格，但内网隔离性可能就会略差，这是就可能发生内部服务API被调用者误调用或者乱调用的问题<br>为了使用方便，内部的一些通用API是不需要鉴权的，但当需要排查问题的时候，如果有多个使用方，很难甄别到底是谁调用的<br>Orange提供的WAF插件可以解决这个问题：</p>
<p>如对API请求做白名单限制，白名单可以以比较常用的IP、Header作为判断条件<br>Orange提供的默认插件都有Log功能，可将某条匹配规则的Log开启，这样出现问题时就可以根据匹配规则的Log，然后结合Nginx本身的访问日志来甄别流量来源了</p>
<ul>
<li>Case 3 *<br>应用的AB测试或者流量切分，虽然业界已经有很多方案可供参考，各个公司或团队也有相应实现，Orange给出了另一种动态解决方案</li>
</ul>
<p>由自定义的条件表达式选择出某部分流量，动态分流到指定的upstream server，结束后只需要关闭这条规则即可<br>线上问题排查，如果某个API出了问题，可临时添加一条规则，将测试账户的流量打到某台机器或者某个新的bug fix的upstream server，待排查完后清除规则、升级bug fix版本</p>
<h3 id="二、-安装配置："><a href="#二、-安装配置：" class="headerlink" title="二、 安装配置："></a>二、 安装配置：</h3><p>安装依赖</p>
<pre><code class="bash"><span class="comment">## lor框架: 版本在v0.1.4+</span>
git <span class="built_in">clone</span> https://github.com/sumory/lor
<span class="built_in">cd</span> lor &amp; sh install.sh

git <span class="built_in">clone</span> https://github.com/sumory/orange.git
<span class="built_in">cd</span> orange
mysql -uroot -p 
create database orange;
user orange;
<span class="built_in">source</span> install/orange-v0.6.0.sql;


<span class="built_in">cd</span> /usr/<span class="built_in">local</span>/orange
nginx -p `<span class="built_in">pwd</span>` -c ./conf/nginx.conf <span class="_">-s</span> stop
</code></pre>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-calendar"></i>
	<a class="article-category-link" href="/categories/linux/">linux</a><a class="article-category-link" href="/categories/linux/运维/">运维</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/22/orange/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-mysql-issume" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/22/mysql-issume/">mysql_issume</a>
    </h1>
  

        <a href="/2016/12/22/mysql-issume/" class="archive-article-date">
  	<time datetime="2016-12-22T07:05:44.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-22</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-ERROR-1820-HY000"><a href="#1-ERROR-1820-HY000" class="headerlink" title="1. ERROR 1820 (HY000):"></a>1. ERROR 1820 (HY000):</h3><p>You must reset your password using ALTER USER statement before executing this st<br>本地 mac mysql升级到5.7 然后有这个提示</p>
<pre><code class="bash"><span class="built_in">set</span> PASSWORD = PASSWORD(<span class="string">'123456'</span>);
</code></pre>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-calendar"></i>
	<a class="article-category-link" href="/categories/linux/">linux</a><a class="article-category-link" href="/categories/linux/数据库/">数据库</a><a class="article-category-link" href="/categories/linux/数据库/运维/">运维</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/22/mysql-issume/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-定时清理文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/21/定时清理文件/">定时清理文件</a>
    </h1>
  

        <a href="/2016/12/21/定时清理文件/" class="archive-article-date">
  	<time datetime="2016-12-21T06:22:16.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-21</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="定时清理文件脚本"><a href="#定时清理文件脚本" class="headerlink" title="定时清理文件脚本"></a>定时清理文件脚本</h3><pre><code class="bash"><span class="meta">#!/bin/bash</span>
<span class="built_in">echo</span> <span class="_">-e</span>  `date`
location=<span class="string">"/srv/tmp/"</span>
logdir=<span class="variable">${location}</span>/<span class="built_in">log</span>
[ <span class="_">-d</span> <span class="variable">${logdir}</span> ] || mkdir -p   <span class="variable">${logdir}</span>
filelist=`find <span class="variable">${location}</span> -mtime +7  -type f |grep .xls `
<span class="comment">#设置IFS（the Internal Field Separator）不要用空格做为IFS，选择其他的符号</span>
IFS=$(<span class="built_in">echo</span> -en <span class="string">"\n\b"</span>)
<span class="built_in">echo</span> <span class="variable">$IFS</span>
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">${filelist}</span>
<span class="keyword">do</span>
  rm -rf <span class="variable">$i</span>
  <span class="built_in">echo</span> <span class="variable">$i</span><span class="string">"  was deleted!"</span>
<span class="keyword">done</span>
<span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"********************************"</span>
<span class="comment">#echo -e  `date`&gt;&gt; ${logdir}/log.txt</span>
<span class="comment">#echo -e "${filelist}" &gt;&gt; ${logdir}/log.txt</span>
<span class="comment">#echo -e "********************************" &gt;&gt; ${logdir}/log.txt</span>
</code></pre>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-calendar"></i>
	<a class="article-category-link" href="/categories/linux/">linux</a><a class="article-category-link" href="/categories/linux/数据库/">数据库</a><a class="article-category-link" href="/categories/linux/数据库/运维/">运维</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/21/定时清理文件/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/20/hello-world/">Hello hexo ,hello World</a>
    </h1>
  

        <a href="/2016/12/20/hello-world/" class="archive-article-date">
  	<time datetime="2016-12-20T10:11:59.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-20</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一直想弄个自己的博客，但是没什么动力，网上介绍hexo,感觉这个正适合自己，<br>所以自己就搞了一个，所以就有了这个的存在！</p>
<h2 id="HEXO教程"><a href="#HEXO教程" class="headerlink" title="HEXO教程"></a>HEXO教程</h2><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>更多方法参考 hexo官网: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="启动服务-默认端口-4000"><a href="#启动服务-默认端口-4000" class="headerlink" title="启动服务 默认端口 4000"></a>启动服务 默认端口 4000</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>更多参考: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="生成静态html页面"><a href="#生成静态html页面" class="headerlink" title="生成静态html页面"></a>生成静态html页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>更多参考: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="部署到远程服务器-git-pages"><a href="#部署到远程服务器-git-pages" class="headerlink" title="部署到远程服务器(git pages)"></a>部署到远程服务器(git pages)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>更多参考: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h3 id="部署文档参考："><a href="#部署文档参考：" class="headerlink" title="部署文档参考："></a>部署文档参考：</h3><p><a href="http://jiji262.github.io/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="external">令狐葱手把手教你Hexo+Github Pages搭建博客</a><br><a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">GitHub Pages + Hexo搭建博客</a><br><a href="https://qiutc.me/post/使用hexo-github搭建静态博客.html" target="_blank" rel="external">使用hexo+github搭建静态博客</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/20/hello-world/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-rabbitmq-install" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/19/rabbitmq-install/">rabbitmq_install</a>
    </h1>
  

        <a href="/2016/12/19/rabbitmq-install/" class="archive-article-date">
  	<time datetime="2016-12-19T08:55:38.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-19</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、安装："><a href="#一、安装：" class="headerlink" title="一、安装："></a>一、安装：</h3><pre><code class="bash">rpm -Uvh http://download.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-8.noarch.rpm
yum clean all
yum install erlang
rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc
 yum install rabbitmq-server-3.6.6-1.noarch.rpm
yum list |grep rabbit
yum install rabbitmq-server.noarch 
systemctl <span class="built_in">enable</span> rabbitmq-server
systemctl start rabbitmq-server
systemctl status rabbitmq-server
</code></pre>
<h3 id="二、配置-添加user和vhost："><a href="#二、配置-添加user和vhost：" class="headerlink" title="二、配置 添加user和vhost："></a>二、配置 添加user和vhost：</h3><pre><code class="bash">rabbitmqctl add_vhost apis
rabbitmqctl add_vhost search
rabbitmqctl add_user shgt password
rabbitmqctl  set_permissions  -p  apis  shgt  ConfP  WriteP  ReadP
rabbitmqctl  set_permissions -p apis  shgt <span class="string">'.*'</span> <span class="string">'.*'</span> <span class="string">'.*'</span>
rabbitmqctl  set_permissions -p search  shgt <span class="string">'.*'</span> <span class="string">'.*'</span> <span class="string">'.*'</span>
rabbitmqctl list_user_permissions shgt
</code></pre>
<h3 id="三、设置-web管理帐号："><a href="#三、设置-web管理帐号：" class="headerlink" title="三、设置 web管理帐号："></a>三、设置 web管理帐号：</h3><pre><code class="bash">/usr/lib/rabbitmq/bin/rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management 
systemctl stop rabbitmq-server
systemctl start rabbitmq-server
systemctl status rabbitmq-server
rabbitmqctl  set_user_tags  shgt  monitoring
rabbitmqctl list_user_permissions shgt
rabbitmqctl list_permissions -p apis
rabbitmqctl add_user <span class="built_in">jobs</span> password
rabbitmqctl  set_user_tags  <span class="built_in">jobs</span>  monitoring
</code></pre>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-calendar"></i>
	<a class="article-category-link" href="/categories/linux/">linux</a><a class="article-category-link" href="/categories/linux/数据库/">数据库</a><a class="article-category-link" href="/categories/linux/数据库/运维/">运维</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/19/rabbitmq-install/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-openresty" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/10/openresty/">openresty</a>
    </h1>
  

        <a href="/2016/12/10/openresty/" class="archive-article-date">
  	<time datetime="2016-12-10T02:43:27.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-10</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><p>下载地址：<a href="https://openresty.org/cn/download.html" target="_blank" rel="external">https://openresty.org/cn/download.html</a><br><a href="https://openresty.org/download/openresty-1.11.2.2.tar.gz" target="_blank" rel="external">openresty-1.11.2.2.tar.gz</a></p>
<p>Fedora 和 RedHat 用户</p>
<pre><code class="bash">yum install readline-devel pcre-devel openssl-devel gcc
./configure --prefix=/opt/openresty \
            --with-luajit \
            --without-http_redis2_module \
            --with-http_iconv_module \
            --with-http_postgres_module
</code></pre>
<p>Mac OS X (Darwin) 用户</p>
<pre><code class="bash">brew update
brew install pcre openssl
./configure \
   --with-cc-opt=<span class="string">"-I/usr/local/opt/openssl/include/ -I/usr/local/opt/pcre/include/"</span> \
   --with-ld-opt=<span class="string">"-L/usr/local/opt/openssl/lib/ -L/usr/local/opt/pcre/lib/"</span> \
   -j8
</code></pre>
<p>环境变量配置：<br>opm</p>
<pre><code class="bash"><span class="built_in">export</span> OPENRETY_HOME=/usr/<span class="built_in">local</span>/openresty/
<span class="built_in">export</span> PATH=<span class="variable">$OPENRETY_HOME</span>/bin:<span class="variable">$PATH</span>
ln <span class="_">-s</span>  /usr/<span class="built_in">local</span>/openresty/nginx/sbin/nginx  /usr/<span class="built_in">local</span>/bin/nginx
</code></pre>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-calendar"></i>
	<a class="article-category-link" href="/categories/linux/">linux</a><a class="article-category-link" href="/categories/linux/运维/">运维</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/10/openresty/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 记事薄
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/介绍/" style="font-size: 10px;">介绍</a> <a href="/tags/技术/" style="font-size: 20px;">技术</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://clude.github.io/">奔跑的鱼</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做一点微末的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>